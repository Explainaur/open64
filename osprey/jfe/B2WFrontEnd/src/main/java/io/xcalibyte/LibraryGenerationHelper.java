/*
 * Copyright (C) 2021 Xcalibyte (Shenzhen) Limited.
 */

package io.xcalibyte;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import soot.Modifier;
import soot.SootClass;
import soot.SootMethod;
import soot.VoidType;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

public class LibraryGenerationHelper {
  private static Logger logger = LogManager.getLogger(LibraryGenerationHelper.class);

  private static void dumpVTable(List<SootClass> visitedClazzList) {
    if (!B2WFrontEnd.i().isLibGenOnly()) {
      return;
    }
    logger.debug("Dump vtables");
    // write to file
    final File outFile = new File(B2WFrontEnd.i().getLibrarySubsidiaryOutputFileName());
    logger.debug("Writing to file {}", outFile.getAbsoluteFile());
    try {
      FileWriter writer = new FileWriter(outFile);
      for (SootClass clazz : visitedClazzList) {
        // Not adding the interface classes, since they don't have V-Tables.
        if (clazz.isInterface()) {
          logger.debug("Skip interface : {}", clazz.getName());
          continue;
        }
        logger.debug("Class : {}", clazz.getName());
        final SymbolHandler.TableInfo<SootMethod> vtableInfo = SymbolHandler.getClassInfo(clazz).getVtable();
        // prepare to dump ZTV for such info.
        writer.write(MangleTool.mangleForClassInternalSymbol(clazz.getName(), InternalConstants.SymbolCategory.VTABLE));
        writer.write("\n");
        writer.write(": ");
        writer.write(MangleTool.mangleForClassInternalSymbol(clazz.getName(), InternalConstants.SymbolCategory.CLASS_SYMBOL));
        writer.write("\n");
        writer.write(" ");
        writer.write(MangleTool.mangleForClassInternalSymbol(clazz.getName(), InternalConstants.SymbolCategory.CLASS_SYMBOL));
        writer.write("\n");
        for (int it = 0; it < vtableInfo.size(); it++) {
          final SootMethod m = vtableInfo.get(it);
          if (!m.isAbstract()) {
            writer.write(" ");
            writer.write(MangleTool.mangle(vtableInfo.get(it)));
            writer.write("\n");
          } else {
            logger.debug("Skipping abstract method {}", m.getName());
          }
        }
        writer.write("\n");
      }
      writer.close();
    } catch (IOException e) {
      e.printStackTrace();
      throw new RuntimeException("Writing properties file failed under " + outFile.getAbsolutePath() );
    }
  }

  private static void dumpMethodName(List<SootClass> visitedClassList) {
    if (!B2WFrontEnd.i().isLibGenOnly() || !B2WFrontEnd.i().needToDumpMethodName()) {
      return;
    }
    // write to file
    String filePath = B2WFrontEnd.i().getLibrarySubsidiaryOutputFileName() + ".mi";
    final File outFile = new File(filePath);
    logger.debug("Writing to file {}", outFile.getAbsoluteFile());
    try {
      FileWriter writer = new FileWriter(outFile);
      for (SootClass clazz: visitedClassList) {
        boolean dumpNewLine = false;
        StringBuilder lines = new StringBuilder();
        for (SootMethod method: clazz.getMethods()) {
          // need not to dump private or protect method
          if (!method.isPublic()) {
            continue;
          }
          /*
            can't dump bridge method into method table, bridge method was generated by javac,
            user need not to annotate bridge method.
            bridge method and it called method have different return type, but have same method name and params
          */
          if(Modifier.isSynthetic(method.getModifiers()) && Modifier.isVolatile(method.getModifiers())) {
            continue;
          }
          lines.append(method.getSignature());
          lines.append('|');
          lines.append(MangleTool.mangle(method));
          // type information
          lines.append('|');
          if (method.getReturnType() instanceof VoidType) {
            lines.append('V');
          } else {
            lines.append('R');
          }
          // parameter number
          lines.append('|');
          lines.append(method.getParameterCount());
          // static, instance or constructor
          lines.append('|');
          if (method.isConstructor()) {
            // constructor
            lines.append('C');
          } else if (!method.isStatic()) {
            // instance method
            lines.append('I');
          } else {
            // static method
            lines.append('S');
          }
          lines.append('\n');
          dumpNewLine = true;
        }
        if (dumpNewLine) {
          lines.append('\n');
          writer.write(lines.toString());
        }
      }
      writer.close();
    } catch (IOException e) {
      e.printStackTrace();
      throw new RuntimeException("Writing properties file failed under " + outFile.getAbsolutePath());
    }
  }

  static void dump(List<SootClass> visitedClassList) {
    dumpVTable(visitedClassList);
    dumpMethodName(visitedClassList);
  }
}
